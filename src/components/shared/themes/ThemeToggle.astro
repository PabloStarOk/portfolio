---
import SunIcon from "@lucide/astro/icons/sun";
import MoonIcon from "@lucide/astro/icons/moon";
import SunMoonIcon from "@lucide/astro/icons/sun-moon";

interface Props {
  /*
   * Determines if the theme toggle is visible on mobile and tablet devices.
   * Set to `true` for mobile-specific instances.
   */
  targetDevice?: "mobile" | "desktop";
}

const { targetDevice } = Astro.props;
---

<div
  id="toggleContainer"
  class="theme-toggle"
  data-state="auto"
  data-target-device={targetDevice}
>
  <button
    id="themeToggle"
    class="theme-toggle__button"
    data-state="auto"
    aria-label="Toggle Theme"
  >
    <div class="theme-toggle__icons">
      <SunMoonIcon
        size={20}
        color="var(--color-foreground-neutral-onneutral-primary)"
        class="theme-toggle__icon"
        data-icon="auto"
      />

      <MoonIcon
        size={20}
        color="var(--color-foreground-neutral-onneutral-primary)"
        class="theme-toggle__icon"
        data-icon="dark"
      />

      <SunIcon
        size={20}
        color="var(--color-foreground-neutral-onneutral-primary)"
        class="theme-toggle__icon"
        data-icon="light"
      />
    </div>
    <p class="theme-toggle__content">Auto</p>
  </button>
</div>

<style>
  /* Classes */
  .theme-toggle {
    position: relative;

    background: transparent;

    display: flex;
    flex-direction: row;

    min-width: 5.5rem;
    max-height: 2.5rem;

    padding: var(--space-100);
    border-radius: var(--radius-200);

    box-sizing: border-box;
  }

  .theme-toggle__button {
    width: 1.8rem;
    min-height: 1.8rem;
    height: 100%;

    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    gap: var(--space-150);

    padding: var(--space-50);
    background: var(--color-primary-1000);
    border-radius: var(--radius-100);
    border: transparent;

    transform: translateX(0);

    transition:
      transform 0.2s ease-in-out,
      width 0.2s ease;
  }

  .theme-toggle__icons {
    position: relative;
    width: 1.2rem;
    height: 1.2rem;
  }

  .theme-toggle__icon {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    transform: scale(0.8) rotate(-90deg);
    transition:
      opacity 0.3s ease,
      transform 0.3s ease;
  }

  .theme-toggle__content {
    opacity: 0;
    visibility: hidden;
    display: none;
    font-family: var(--typography-font-family-default);
    font-size: var(--typography-body-size-small);
    font-weight: var(--typography-body-font-weight-strong);
    color: var(--color-foreground-neutral-onneutral-primary);

    transition: opacity 0.3s ease-in-out;
  }

  /* Pseudo Elements */
  .theme-toggle::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;

    /* Solid gradient border */
    border: 1px solid transparent;
    background: var(--color-primary-1000);
    mask:
      linear-gradient(#fff 0 0) content-box,
      linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask-composite: destination-out;

    border-radius: inherit;
    z-index: 0;
    pointer-events: none;
  }

  /* Pseudo Classes */
  .theme-toggle__button:hover {
    cursor: pointer;
  }

  .theme-toggle__button:focus-visible {
    outline: var(--space-100) solid var(--color-primary-gradient-right-1000);
    outline-width: 0.188rem;
    outline-offset: var(--space-200);
    border-radius: var(--radius-50);

    transition: outline-offset 0.2s ease-in-out;
  }

  /* Data Attributes */
  .theme-toggle[data-state="light"] {
    justify-content: flex-end;
  }

  .theme-toggle__button[data-state="auto"] {
    width: 100%;
  }

  .theme-toggle__button[data-state="auto"] [data-icon="auto"],
  .theme-toggle__button[data-state="dark"] [data-icon="dark"],
  .theme-toggle__button[data-state="light"] [data-icon="light"] {
    opacity: 1;
    transform: scale(1) rotate(0deg);
  }

  .theme-toggle__button[data-state="auto"] .theme-toggle__content {
    visibility: visible;
    opacity: 1;
    display: inline;
  }

  .theme-toggle[data-target-device="desktop"] {
    display: none !important;
  }

  /* Media Queries */
  @media screen and (max-width: 64em) {
    .theme-toggle[data-target-device="mobile"] {
      display: none !important;
    }
  }

  @media screen and (min-width: 64em) {
    .theme-toggle[data-target-device="desktop"] {
      display: flex !important;
    }
  }
</style>

<script is:inline>
  // Apply styles before loading.
  (function () {
    const storedTheme = window.theme.getTheme();
    const toggles = document.querySelectorAll(".theme-toggle__button");

    for (const toggle of toggles) {
      const container = toggle.closest(".theme-toggle");

      toggle.dataset.state = storedTheme;
      container.dataset.state = storedTheme;
    }
  })();
</script>

<script>
  enum Theme {
    Auto = "auto",
    Dark = "dark",
    Light = "light",
  }

  type ToggleState = {
    label: string;
    width: string;
    hasTimeout: boolean;
    timeout?: number;
  };

  class ThemeToggle {
    containerElement: HTMLDivElement;
    buttonElement: HTMLButtonElement;
    paragraphElement: HTMLParagraphElement;
    states: Map<string, ToggleState>;
    defaultState: ToggleState;
    animationTimeout: Timeout = 0;

    private boundSwitchTheme: () => void;
    private boundOnThemeChanged: (event: Event) => void;

    constructor(
      containerElement: HTMLDivElement,
      buttonElement: HTMLButtonElement,
      paragraphElement: HTMLParagraphElement,
      states: Map<string, ToggleState>,
      defaultState: ToggleState
    ) {
      this.containerElement = containerElement;
      this.buttonElement = buttonElement;
      this.paragraphElement = paragraphElement;
      this.states = states;
      this.defaultState = defaultState;

      this.boundSwitchTheme = this.switchTheme.bind(this);
      this.boundOnThemeChanged = this.onThemeChanged.bind(this);
      this.buttonElement.addEventListener("click", this.boundSwitchTheme);
      document.addEventListener("theme-changed", this.boundOnThemeChanged);
      this.switchState(window.theme.getTheme() as Theme);
    }

    destroy() {
      this.buttonElement.removeEventListener("click", this.boundSwitchTheme);
      document.removeEventListener("theme-changed", this.boundOnThemeChanged);
    }

    private switchTheme() {
      const stateCycle = [Theme.Dark, Theme.Auto, Theme.Light];
      const currentState =
        (this.buttonElement.dataset.state as Theme) || Theme.Dark;

      const nextThemeIndex =
        (stateCycle.indexOf(currentState) + 1) % stateCycle.length;
      const nextTheme = stateCycle[nextThemeIndex];
      window.theme.setTheme(nextTheme);
    }

    private onThemeChanged(event: Event) {
      const themeChangedEvent = event as CustomEvent<{ theme: string }>;
      const theme = themeChangedEvent.detail.theme as Theme;
      this.switchState(theme);
    }

    private switchState(targetTheme: Theme) {
      if (this.buttonElement.dataset.state === targetTheme) return;

      clearTimeout(this.animationTimeout);

      const state = toggleStates.get(targetTheme) || this.defaultState;

      if (!state) return;

      // Fill the container to simulate an translation animation. (Specially used to move from light theme (right side) to dark theme (left side) mode)
      if (state.hasTimeout) this.buttonElement.style.width = "100%";

      this.paragraphElement.textContent = state.label;
      this.animationTimeout = setTimeout(() => {
        this.containerElement.dataset.state = targetTheme;
        this.buttonElement.style.width = state.width;
        this.buttonElement.dataset.state = targetTheme;
      }, state.timeout);
    }
  }

  const toggleStates: Map<Theme, ToggleState> = new Map([
    [
      Theme.Auto,
      {
        label: "Auto",
        width: "100%",
        hasTimeout: false,
        timeout: 0,
      },
    ],
    [
      Theme.Dark,
      {
        label: "",
        width: "1.8rem",
        hasTimeout: true,
        timeout: 150,
      },
    ],
    [
      Theme.Light,
      {
        label: "",
        width: "1.8rem",
        hasTimeout: false,
        timeout: 0,
      },
    ],
  ]);

  const themeToggles: ThemeToggle[] = [];
  function setupThemeToggles() {
    document.querySelectorAll(".theme-toggle__button").forEach((button) => {
      const container = button.closest(".theme-toggle") as HTMLDivElement;
      const paragraph = button.querySelector(
        ".theme-toggle__content"
      ) as HTMLParagraphElement;

      const themeToggle = new ThemeToggle(
        container,
        button as HTMLButtonElement,
        paragraph,
        toggleStates,
        toggleStates.get(Theme.Auto) as ToggleState
      );
      themeToggles.push(themeToggle);
    });
  }

  function cleanupThemeToggles() {
    themeToggles.forEach((instance) => instance.destroy());
    themeToggles.length = 0;
  }

  setupThemeToggles();
  document.addEventListener("astro:before-swap", cleanupThemeToggles);
  document.addEventListener("astro:page-load", () => {
    cleanupThemeToggles();
    setupThemeToggles();
  });
</script>
